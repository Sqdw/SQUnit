using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using OpenQA.Selenium;
using OpenQA.Selenium.Firefox;

namespace SQUnit
{
	/// <summary>
	/// The class that takes care of firing a browser session using Selenium and extracting the QUnit test result information.
	/// </summary>
	public class QUnitParser : IDisposable
	{
		readonly int _maxWaitInMs;
		readonly Lazy<IWebDriver> _driver;
		IWebDriver Driver
		{
			get { return _driver.Value; }
		}

		/// <summary>
		/// Default constructor.
		/// </summary>
		/// <param name="maxWaitInMs">The maximum number of milliseconds before the tests should timeout after page load; -1 for infinity</param>
		public QUnitParser(int maxWaitInMs)
		{
			_maxWaitInMs = maxWaitInMs < 0 ? Int32.MaxValue : maxWaitInMs;
			_driver = new Lazy<IWebDriver>(() => new FirefoxDriver());
		}

		/// <summary>
		/// Returns an array of QUnitTestResult objects given a test page URI.
		/// </summary>
		/// <param name="testPage">The URI of the test page; either a URL or a file path</param>
		/// <returns>An array of QUnitTestResult objects</returns>
		public IEnumerable<QUnitTestResult> GetQUnitTestResults(string testPage)
		{
			Driver.Navigate().GoToUrl(testPage);
			return GrabTestResultsFromWebPage(testPage);
		}

		private IEnumerable<QUnitTestResult> GrabTestResultsFromWebPage(string testPage)
		{
			var stillRunning = true;
			IWebElement testOl = null;
			var wait = 0;

			// BEWARE: This logic is tightly coupled to the structure of the HTML generated by the QUnit test runner

			while (stillRunning && wait <= _maxWaitInMs)
			{
				testOl = Driver.FindElements(By.Id("qunit-tests")).ToArray()[0];

				stillRunning = testOl.FindElements(By.TagName("li")).Any(e => e.GetAttribute("class") == "running");

				if (stillRunning && wait < _maxWaitInMs) Thread.Sleep(100);
				wait += 100;
			}

			foreach (var listItem in testOl.FindElements(By.CssSelector("li[id^='test-output']")))
			{
				var testName = listItem.FindElement(By.ClassName("test-name")).Text;
				var resultClass = listItem.GetAttribute("class");
				var failedAssert = string.Empty;
				if (resultClass == "fail")
				{
					failedAssert = listItem.FindElement(By.ClassName("fail")).Text;
				}

				yield return new QUnitTestResult
				{
					FileName = testPage,
					TestName = RemoveAssertCounts(testName),
					Result = resultClass,
					Message = failedAssert
				};
			}

		}

		private static string RemoveAssertCounts(string fullTagText)
		{
			if (fullTagText == null) return String.Empty;
			int parenPosition = fullTagText.IndexOf('(');
			if (parenPosition > 0)
			{
				return fullTagText.Substring(0, parenPosition);
			}
			return fullTagText;
		}

		#region IDisposable
		public virtual void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (_driver.IsValueCreated)
			{
				Driver.Close();
				Driver.Dispose();
			}
		}

		~QUnitParser()
		{
			Dispose(false);
		}
		#endregion

	}
}
